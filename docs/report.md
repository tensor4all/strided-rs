# mdarray-strided ベンチマークレポート

**実行日**: 2026-01-23  
**環境**: Rust release build, optimized

## 概要

`mdarray-strided` クレートのパフォーマンスを、naive実装（ネストしたループ）と比較したベンチマーク結果です。各ベンチマークは、連続配列（contiguous）とストライド配列（permuted/transposed）の両方のケースを評価しています。

## ベンチマーク結果

### 1. Copy Operations

#### 1.1 Copy Permuted (転置配列のコピー)

| Size | Method | Time (mean) | Throughput | Speedup vs Naive |
|------|--------|--------------|------------|------------------|
| 100×100 | naive | 4.44 µs | 2.25 Gelem/s | 1.00× |
| 100×100 | strided | 5.30 µs | 1.89 Gelem/s | **0.84×** (slower) |
| 500×500 | naive | 82.23 µs | 3.04 Gelem/s | 1.00× |
| 500×500 | strided | 103.19 µs | 2.42 Gelem/s | **0.80×** (slower) |
| 1000×1000 | naive | 359.74 µs | 2.78 Gelem/s | 1.00× |
| 1000×1000 | strided | 431.26 µs | 2.32 Gelem/s | **0.83×** (slower) |

**分析**: 2Dの書き込み連続パスを追加したことで、以前より大幅に改善し、naiveに近い水準まで縮まりました。依然として読み取り側が非連続アクセスになるため、わずかに遅い傾向は残ります。

#### 1.2 Copy Contiguous (連続配列のコピー)

| Size | Method | Time (mean) | Throughput | Speedup vs Naive |
|------|--------|--------------|------------|------------------|
| 100×100 | naive | 1.98 µs | 5.06 Gelem/s | 1.00× |
| 100×100 | strided | 3.03 µs | 3.30 Gelem/s | **0.65×** (slower) |
| 100×100 | uninit | 1.34 µs | 7.46 Gelem/s | **1.48×** (faster) |
| 500×500 | naive | 37.70 µs | 6.63 Gelem/s | 1.00× |
| 500×500 | strided | 52.35 µs | 4.78 Gelem/s | **0.72×** (slower) |
| 500×500 | uninit | 33.37 µs | 7.49 Gelem/s | **1.13×** (faster) |
| 1000×1000 | naive | 149.48 µs | 6.69 Gelem/s | 1.00× |
| 1000×1000 | strided | 209.34 µs | 4.78 Gelem/s | **0.71×** (slower) |
| 1000×1000 | uninit | 153.15 µs | 6.53 Gelem/s | **0.98×** (同等) |

**分析**: zero-initialization を避けられる `copy_into_uninit` は、連続コピーで naive を上回る速度が出ます。`strided` は `Tensor::zeros` の初期化コスト分が残るため、差が出やすいです。

### 2. Zip Map Operations (要素ごとの二項演算)

#### 2.1 Zip Map Mixed Strides (混合ストライド)

| Size | Method | Time (mean) | Speedup vs Naive |
|------|--------|--------------|------------------|
| 100×100 | naive | 12.31 µs | 1.00× |
| 100×100 | strided | 5.64 µs | **2.18×** (faster) |
| 500×500 | naive | 296.31 µs | 1.00× |
| 500×500 | strided | 113.69 µs | **2.61×** (faster) |
| 1000×1000 | naive | 1.25 ms | 1.00× |
| 1000×1000 | strided | 551.68 µs | **2.27×** (faster) |

**分析**: 2D混合ストライド向けの専用パスを導入し、naiveより 2-2.6x 高速になりました。書き込み連続の内側ループを優先し、ポインタ増分でオーバーヘッドを削減しています。

#### 2.2 Zip Map Contiguous (連続配列)

| Size | Method | Time (mean) | Speedup vs Naive |
|------|--------|--------------|------------------|
| 100×100 | naive | 10.69 µs | 1.00× |
| 100×100 | strided | 3.38 µs | **3.16×** (faster) |
| 500×500 | naive | 258.00 µs | 1.00× |
| 500×500 | strided | 66.27 µs | **3.89×** (faster) |
| 1000×1000 | naive | ~1.03 ms | 1.00× |
| 1000×1000 | strided | ~265 µs | **~3.89×** (faster) |

**分析**: 連続配列では、strided実装はnaive実装より**約3-4倍高速**です。これは、連続アクセスパターンで最適化されたループが効果的に動作しているためです。

### 3. Reduce Operations

#### 3.1 Reduce Transposed (転置配列のリダクション)

| Size | Method | Time (mean) | Speedup vs Naive |
|------|--------|--------------|------------------|
| 100×100 | naive | 9.21 µs | 1.00× |
| 100×100 | strided | 10.64 µs | **0.87×** (slower) |
| 500×500 | naive | 231.76 µs | 1.00× |
| 500×500 | strided | 238.48 µs | **0.97×** (slower) |
| 1000×1000 | naive | 954.44 µs | 1.00× |
| 1000×1000 | strided | 942.37 µs | **1.01×** (同等) |

**分析**: 転置配列のリダクションでは、小さいサイズではオーバーヘッドが影響しますが、大きいサイズ（1000×1000）ではほぼ同等の性能です。

#### 3.2 Reduce Contiguous (連続配列のリダクション)

| Size | Method | Time (mean) | Speedup vs Naive |
|------|--------|--------------|------------------|
| 100×100 | naive | 9.15 µs | 1.00× |
| 100×100 | strided | 9.30 µs | **0.98×** (同等) |
| 500×500 | naive | 226.36 µs | 1.00× |
| 500×500 | strided | 230.89 µs | **0.98×** (同等) |
| 1000×1000 | naive | 918.41 µs | 1.00× |
| 1000×1000 | strided | 925.97 µs | **0.99×** (同等) |

**分析**: 連続配列のリダクションでは、naive実装とほぼ同等の性能です。連続アクセスパターンでは、最適化の効果が限定的です。

### 4. Specialized Operations

#### 4.1 Symmetrize (対称化: `B = (A + Aᵀ) / 2`)

**サイズ**: 4000×4000

| Method | Time (mean) | Throughput | Speedup vs Naive |
|--------|--------------|------------|------------------|
| naive | 62.27 ms | 257 Melem/s | 1.00× |
| strided | 38.98 ms | 411 Melem/s | **1.60×** (faster) |

**分析**: 特化カーネル `symmetrize_into` は、タイルベースの反復と `(i,j)/(j,i)` の同時更新により、naive実装より**約1.6倍高速**です。キャッシュ効率が大幅に改善されています。

#### 4.2 Scale Transpose (スケール転置: `B = α * Aᵀ`)

**サイズ**: 1000×1000

| Method | Time (mean) | Throughput | Speedup vs Naive |
|--------|--------------|------------|------------------|
| naive | 734.41 µs | 1.36 Gelem/s | 1.00× |
| strided (default) | 692.81 µs | 1.44 Gelem/s | **1.06×** (faster) |
| strided (tile=16) | 674.47 µs | 1.48 Gelem/s | **1.09×** (faster) |
| strided (tile=24) | 862.04 µs | 1.16 Gelem/s | **0.85×** (slower) |
| strided (tile=32) | 681.36 µs | 1.47 Gelem/s | **1.08×** (faster) |

**分析**: 転置カーネルに書き込み連続／読み取り連続の切り替えパスを入れたことで、naiveと同等〜わずかに高速になりました。タイルは 16/32 が良好で、24 は悪化傾向です。

#### 4.3 Nonlinear Map (非線形マップ: `B = A .* exp(-2A) .+ sin(A²)`)

**サイズ**: 1000×1000

| Method | Time (mean) | Throughput | Speedup vs Naive |
|--------|--------------|------------|------------------|
| naive | 13.66 ms | 73.2 Melem/s | 1.00× |
| strided | 13.31 ms | 75.1 Melem/s | **1.03×** (slightly faster) |

**分析**: 非線形マップでは、strided実装はnaive実装とほぼ同等か、わずかに高速です。計算コストが高いため、メモリアクセスパターンの影響が相対的に小さくなっています。

## 総合評価

### 強み

1. **連続配列での zip_map**: 約3-4倍の高速化を達成
2. **対称化操作**: 特化カーネルにより約1.6倍の高速化
3. **混合ストライドのzip_map**: 2-3x 高速化
4. **転置スケール**: naiveと同等〜わずかに高速
5. **転置コピー**: naiveに近い水準まで改善

### 改善の余地

1. **転置配列のコピー**: 依然としてやや遅い（0.73-0.87×）
2. **小さいサイズでのオーバーヘッド**: 100×100程度の小さい配列では、オーバーヘッドが支配的
3. **混合ストライドのzip_map**: 2Dパスで改善済み、さらなる最適化余地は限定的

### 推奨事項

1. **連続配列の最適化**: 連続配列でのパフォーマンスは良好。さらなる最適化の余地は限定的
2. **ストライド配列の最適化**: 混合ストライド演算や小サイズ向けのオーバーヘッド削減が必要
3. **特化カーネルの拡張**: `symmetrize_into` のように、特定のパターンに特化したカーネルを追加することで、さらなる高速化が期待できる

## 技術的詳細

### 実装の特徴

- **ループ順序最適化**: ストライドパターンに基づいてループ順序を最適化
- **キャッシュブロッキング**: L1キャッシュサイズ（32KB）を考慮したブロックサイズの計算
- **連続アクセスパスの最適化**: 連続配列では `ptr::add(1)` による線形反復を使用
- **特化カーネル**: 対称化や転置スケールなどの特定パターンに特化したカーネル

### ベンチマーク設定

- **サンプル数**: 通常100サンプル、大きなベンチマーク（symmetrize_aat, scale_transpose, nonlinear_map）は10サンプル
- **ウォームアップ時間**: 3秒
- **測定時間**: 通常5秒、大きなベンチマークは10秒
- **ビルド設定**: `--release` フラグで最適化ビルド

## 結論

`mdarray-strided` は、連続配列での要素ごとの演算や特定の操作（対称化）で優れたパフォーマンスを示しています。転置コピーとスケール転置に加え、混合ストライドの zip_map も専用パスにより大きく改善しました。一方で、小サイズでのオーバーヘッドには引き続き最適化の余地があります。

特に、連続配列での `zip_map2_into` は約3-4倍の高速化を達成しており、実用的な価値が高いです。ストライド配列でのパフォーマンス改善は、今後の最適化の焦点となるでしょう。
