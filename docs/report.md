# mdarray-strided ベンチマークレポート

**実行日**: 2026-01-23  
**環境**: Rust release build, optimized

## 概要

`mdarray-strided` クレートのパフォーマンスを、naive実装（ネストしたループ）と比較したベンチマーク結果です。各ベンチマークは、連続配列（contiguous）とストライド配列（permuted/transposed）の両方のケースを評価しています。

## ベンチマーク結果

### 1. Copy Operations

#### 1.1 Copy Permuted (転置配列のコピー)

| Size | Method | Time (mean) | Throughput | Speedup vs Naive |
|------|--------|--------------|------------|------------------|
| 100×100 | naive | 4.44 µs | 2.25 Gelem/s | 1.00× |
| 100×100 | strided | 5.30 µs | 1.89 Gelem/s | **0.84×** (slower) |
| 500×500 | naive | 82.23 µs | 3.04 Gelem/s | 1.00× |
| 500×500 | strided | 103.19 µs | 2.42 Gelem/s | **0.80×** (slower) |
| 1000×1000 | naive | 359.74 µs | 2.78 Gelem/s | 1.00× |
| 1000×1000 | strided | 431.26 µs | 2.32 Gelem/s | **0.83×** (slower) |

**分析**: 2Dの書き込み連続パスを追加したことで、以前より大幅に改善し、naiveに近い水準まで縮まりました。依然として読み取り側が非連続アクセスになるため、わずかに遅い傾向は残ります。

#### 1.2 Copy Contiguous (連続配列のコピー)

| Size | Method | Time (mean) | Throughput | Speedup vs Naive |
|------|--------|--------------|------------|------------------|
| 100×100 | naive | 1.98 µs | 5.06 Gelem/s | 1.00× |
| 100×100 | strided | 3.03 µs | 3.30 Gelem/s | **0.65×** (slower) |
| 100×100 | uninit | 1.34 µs | 7.46 Gelem/s | **1.48×** (faster) |
| 500×500 | naive | 37.70 µs | 6.63 Gelem/s | 1.00× |
| 500×500 | strided | 52.35 µs | 4.78 Gelem/s | **0.72×** (slower) |
| 500×500 | uninit | 33.37 µs | 7.49 Gelem/s | **1.13×** (faster) |
| 1000×1000 | naive | 149.48 µs | 6.69 Gelem/s | 1.00× |
| 1000×1000 | strided | 209.34 µs | 4.78 Gelem/s | **0.71×** (slower) |
| 1000×1000 | uninit | 153.15 µs | 6.53 Gelem/s | **0.98×** (同等) |

**分析**: zero-initialization を避けられる `copy_into_uninit` は、連続コピーで naive を上回る速度が出ます。`strided` は `Tensor::zeros` の初期化コスト分が残るため、差が出やすいです。

### 2. Zip Map Operations (要素ごとの二項演算)

#### 2.1 Zip Map Mixed Strides (混合ストライド)

| Size | Method | Time (mean) | Speedup vs Naive |
|------|--------|--------------|------------------|
| 100×100 | naive | 12.31 µs | 1.00× |
| 100×100 | strided | 5.64 µs | **2.18×** (faster) |
| 500×500 | naive | 296.31 µs | 1.00× |
| 500×500 | strided | 113.69 µs | **2.61×** (faster) |
| 1000×1000 | naive | 1.25 ms | 1.00× |
| 1000×1000 | strided | 551.68 µs | **2.27×** (faster) |

**分析**: 2D混合ストライド向けの専用パスを導入し、naiveより 2-2.6x 高速になりました。書き込み連続の内側ループを優先し、ポインタ増分でオーバーヘッドを削減しています。

#### 2.2 Zip Map Contiguous (連続配列)

| Size | Method | Time (mean) | Speedup vs Naive |
|------|--------|--------------|------------------|
| 100×100 | naive | 10.69 µs | 1.00× |
| 100×100 | strided | 3.38 µs | **3.16×** (faster) |
| 500×500 | naive | 258.00 µs | 1.00× |
| 500×500 | strided | 66.27 µs | **3.89×** (faster) |
| 1000×1000 | naive | ~1.03 ms | 1.00× |
| 1000×1000 | strided | ~265 µs | **~3.89×** (faster) |

**分析**: 連続配列では、strided実装はnaive実装より**約3-4倍高速**です。これは、連続アクセスパターンで最適化されたループが効果的に動作しているためです。

### 3. Reduce Operations

#### 3.1 Reduce Transposed (転置配列のリダクション)

| Size | Method | Time (mean) | Speedup vs Naive |
|------|--------|--------------|------------------|
| 100×100 | naive | 9.21 µs | 1.00× |
| 100×100 | strided | 10.64 µs | **0.87×** (slower) |
| 500×500 | naive | 231.76 µs | 1.00× |
| 500×500 | strided | 238.48 µs | **0.97×** (slower) |
| 1000×1000 | naive | 954.44 µs | 1.00× |
| 1000×1000 | strided | 942.37 µs | **1.01×** (同等) |

**分析**: 転置配列のリダクションでは、小さいサイズではオーバーヘッドが影響しますが、大きいサイズ（1000×1000）ではほぼ同等の性能です。

#### 3.2 Reduce Contiguous (連続配列のリダクション)

| Size | Method | Time (mean) | Speedup vs Naive |
|------|--------|--------------|------------------|
| 100×100 | naive | 9.15 µs | 1.00× |
| 100×100 | strided | 9.30 µs | **0.98×** (同等) |
| 500×500 | naive | 226.36 µs | 1.00× |
| 500×500 | strided | 230.89 µs | **0.98×** (同等) |
| 1000×1000 | naive | 918.41 µs | 1.00× |
| 1000×1000 | strided | 925.97 µs | **0.99×** (同等) |

**分析**: 連続配列のリダクションでは、naive実装とほぼ同等の性能です。連続アクセスパターンでは、最適化の効果が限定的です。

### 4. Specialized Operations

#### 4.1 Symmetrize (対称化: `B = (A + Aᵀ) / 2`)

**サイズ**: 4000×4000

| Method | Time (mean) | Throughput | Speedup vs Naive |
|--------|--------------|------------|------------------|
| naive | 62.27 ms | 257 Melem/s | 1.00× |
| strided | 38.98 ms | 411 Melem/s | **1.60×** (faster) |

**分析**: 特化カーネル `symmetrize_into` は、タイルベースの反復と `(i,j)/(j,i)` の同時更新により、naive実装より**約1.6倍高速**です。キャッシュ効率が大幅に改善されています。

#### 4.2 Scale Transpose (スケール転置: `B = α * Aᵀ`)

**サイズ**: 1000×1000

| Method | Time (mean) | Throughput | Speedup vs Naive |
|--------|--------------|------------|------------------|
| naive | 734.41 µs | 1.36 Gelem/s | 1.00× |
| strided (default) | 692.81 µs | 1.44 Gelem/s | **1.06×** (faster) |
| strided (tile=16) | 674.47 µs | 1.48 Gelem/s | **1.09×** (faster) |
| strided (tile=24) | 862.04 µs | 1.16 Gelem/s | **0.85×** (slower) |
| strided (tile=32) | 681.36 µs | 1.47 Gelem/s | **1.08×** (faster) |

**分析**: 転置カーネルに書き込み連続／読み取り連続の切り替えパスを入れたことで、naiveと同等〜わずかに高速になりました。タイルは 16/32 が良好で、24 は悪化傾向です。

#### 4.3 Nonlinear Map (非線形マップ: `B = A .* exp(-2A) .+ sin(A²)`)

**サイズ**: 1000×1000

| Method | Time (mean) | Throughput | Speedup vs Naive |
|--------|--------------|------------|------------------|
| naive | 13.31 ms | 75.1 Melem/s | 1.00× |
| strided | 12.93 ms | 77.4 Melem/s | **1.03×** (slightly faster) |

**分析**: 非線形マップでは、strided実装はnaive実装とほぼ同等か、わずかに高速です。計算コストが高いため、メモリアクセスパターンの影響が相対的に小さくなっています。

### 5. 4D Array Operations (Strided.jl README ベンチマーク)

Julia の Strided.jl README.md から移植したベンチマークです。

#### 5.1 Permutedims 4D (4次元配列の順列: `B = permutedims(A, (4,3,2,1))`)

**サイズ**: 32×32×32×32 (1,048,576 要素)

| Method | Time (mean) | Throughput | Speedup vs Naive |
|--------|--------------|------------|------------------|
| naive | 1.02 ms | 1.03 Gelem/s | 1.00× |
| strided | 4.73 ms | 222 Melem/s | **0.22×** (slower) |

**分析**: 4D配列の複雑な順列では、現在のブロッキング戦略が最適化されておらず、naiveより遅くなっています。4Dでは次元数が多いため、ブロッキングのオーバーヘッドが大きくなる傾向があります。

#### 5.2 Multi-Permute Sum (複数順列の和: `zip_map4_into`)

```
B = permutedims(A, (1,2,3,4)) + permutedims(A, (2,3,4,1)) +
    permutedims(A, (3,4,1,2)) + permutedims(A, (4,1,2,3))
```

**サイズ**: 32×32×32×32 (1,048,576 要素)

| Method | Time (mean) | Throughput | Speedup vs Naive |
|--------|--------------|------------|------------------|
| naive | 4.87 ms | 216 Melem/s | 1.00× |
| strided_fused (`zip_map4_into`) | 12.68 ms | 83 Melem/s | **0.38×** (slower) |

**分析**: `zip_map4_into` を使った単一パス実装は、4D配列では naive の4重ループより遅くなっています。これは以下の要因によります：
- 4D配列でのブロッキングオーバーヘッド
- 5つの配列（出力 + 4入力）のストライド計算コスト
- キャッシュ効率が2Dほど良くない

**今後の改善**: 4D配列向けのブロッキング戦略の最適化、または小次元配列での特化パスが必要です。

## 総合評価

### 強み

1. **連続配列での zip_map**: 約3-4倍の高速化を達成
2. **対称化操作**: 特化カーネルにより約1.5倍の高速化
3. **混合ストライドのzip_map**: 2-2.6x 高速化
4. **転置スケール**: naiveと同等〜わずかに高速
5. **転置コピー**: naiveに近い水準まで改善
6. **`zip_map4_into`**: 4配列の単一パス処理が可能（2D配列で効果的）

### 改善の余地

1. **4D配列の操作**: 現在のブロッキング戦略が4D配列に最適化されておらず、naiveより遅い
2. **転置配列のコピー**: 依然としてやや遅い（0.83-0.85×）
3. **小さいサイズでのオーバーヘッド**: 100×100程度の小さい配列では、オーバーヘッドが支配的

### 推奨事項

1. **4D配列のブロッキング戦略最適化**: 現在の戦略は2D配列に最適化されているため、高次元配列向けの改善が必要（[Issue #5](https://github.com/AtelierArith/strided-rs-private/issues/5)）
2. **小サイズ向けのオーバーヘッド削減**: 100×100程度の小さい配列では、ブロッキングをスキップする閾値の調整が有効
3. **特化カーネルの拡張**: `symmetrize_into` のように、特定のパターンに特化したカーネルを追加することで、さらなる高速化が期待できる

## 技術的詳細

### 実装の特徴

- **ループ順序最適化**: ストライドパターンに基づいてループ順序を最適化
- **キャッシュブロッキング**: L1キャッシュサイズ（32KB）を考慮したブロックサイズの計算
- **連続アクセスパスの最適化**: 連続配列では `ptr::add(1)` による線形反復を使用
- **特化カーネル**: 対称化や転置スケールなどの特定パターンに特化したカーネル

### ベンチマーク設定

- **サンプル数**: 通常100サンプル、大きなベンチマーク（symmetrize_aat, scale_transpose, nonlinear_map）は10サンプル
- **ウォームアップ時間**: 3秒
- **測定時間**: 通常5秒、大きなベンチマークは10秒
- **ビルド設定**: `--release` フラグで最適化ビルド

## 結論

`mdarray-strided` は、**2D配列での要素ごとの演算**や**特定の操作（対称化）**で優れたパフォーマンスを示しています：

- **zip_map (連続)**: 3-4倍高速
- **zip_map (混合ストライド)**: 2-2.6倍高速
- **symmetrize**: 1.5倍高速

一方、**4D配列での複雑な順列操作**では、現在のブロッキング戦略が最適化されておらず、naiveより遅くなっています。これは今後の最適化課題です。

`zip_map4_into` の追加により、4配列の単一パス処理が可能になりました。2D配列では効果的ですが、4D配列では追加の最適化が必要です。

### API の成熟度

| 機能 | 2D配列 | 4D配列 |
|------|--------|--------|
| `zip_map2_into` | **推奨** | 要検証 |
| `zip_map4_into` | **推奨** | 要最適化 |
| `symmetrize_into` | **推奨** | N/A |
| `copy_into` (転置) | 同等 | 要最適化 |
